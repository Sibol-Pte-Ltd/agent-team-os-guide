<!DOCTYPE html><!--vzbdtBP5U_venz5tN8oS4--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/56998b7e09014914.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-d282787ed3063711.js"/><script src="/_next/static/chunks/4bd1b696-f785427dddbba9fb.js" async=""></script><script src="/_next/static/chunks/1255-29325acccda77703.js" async=""></script><script src="/_next/static/chunks/main-app-035730848130ded3.js" async=""></script><script src="/_next/static/chunks/app/(authenticated)/layout-8a56e70ab4050a46.js" async=""></script><title>OpenClaw Architecture — Agent Team OS Guide</title><meta name="description" content="Your personal AI agent team, working together to keep your life organized."/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><input type="checkbox" id="menu-toggle" class="menu-toggle"/><label for="menu-toggle" class="hamburger" aria-label="Toggle navigation">☰</label><label for="menu-toggle" class="overlay"></label><div class="site-wrapper"><aside class="sidebar"><div class="sidebar-header"><h1>Agent Team OS</h1><div class="subtitle">User Guide</div></div><nav><div class="nav-section"><a class="nav-link" href="/">Home</a></div><div class="nav-section"><div class="nav-section-title">Getting Started</div><a class="nav-link" href="/getting-started">Quick Start</a><a class="nav-link" href="/getting-started/first-day">Your First Day</a><a class="nav-link" href="/getting-started/setup-checklist">Setup Checklist</a></div><div class="nav-section"><div class="nav-section-title">Notes &amp; Sync</div><a class="nav-link" href="/life-os">What is Notes</a><a class="nav-link" href="/life-os/daily-workflow">Daily Workflow</a><a class="nav-link" href="/life-os/templates">Templates</a><a class="nav-link" href="/life-os/logseq-tips">LogSeq Tips</a></div><div class="nav-section"><div class="nav-section-title">Agents</div><a class="nav-link" href="/agents">Meet Your Agents</a><a class="nav-link" href="/agents/ember">Ember</a><a class="nav-link" href="/agents/scout">Scout</a><a class="nav-link" href="/agents/forge">Forge</a><a class="nav-link" href="/agents/architect">Architect</a><a class="nav-link" href="/agents/trust-levels">Trust Levels</a></div><div class="nav-section"><div class="nav-section-title">Cadence</div><a class="nav-link" href="/cadence">Overview</a><a class="nav-link" href="/cadence/morning-report">Morning Report</a><a class="nav-link" href="/cadence/evening-checkin">Evening Check-in</a><a class="nav-link" href="/cadence/weekly-review">Weekly Review</a><a class="nav-link" href="/cadence/monthly-review">Monthly Review</a></div><div class="nav-section"><div class="nav-section-title">OpenClaw Architecture</div><a class="nav-link active" href="/architecture">Overview</a><a class="nav-link" href="/architecture/channel-adapters">Channel Adapters</a><a class="nav-link" href="/architecture/gateway">Gateway</a><a class="nav-link" href="/architecture/lane-queue">Lane Queue</a><a class="nav-link" href="/architecture/agent-runner">Agent Runner</a><a class="nav-link" href="/architecture/execution-layer">Execution Layer</a></div><div class="nav-section"><div class="nav-section-title">Automation</div><a class="nav-link" href="/automation">Overview</a><a class="nav-link" href="/automation/cron-jobs">Cron Jobs</a><a class="nav-link" href="/automation/notifications">Notifications</a></div><div class="nav-section"><div class="nav-section-title">Troubleshooting</div><a class="nav-link" href="/troubleshooting">Common Issues</a><a class="nav-link" href="/troubleshooting/syncthing">Syncthing</a><a class="nav-link" href="/troubleshooting/faq">FAQ</a></div><div class="nav-section"><div class="nav-section-title">Reference</div><a class="nav-link" href="/reference/commands">Commands</a><a class="nav-link" href="/reference/file-locations">File Locations</a><a class="nav-link" href="/reference/glossary">Glossary</a><a class="nav-link" href="/reference/changelog">Changelog</a></div><div class="nav-section"><div class="nav-section-title">Implementation</div><a class="nav-link" href="/implementation">Status</a><a class="nav-link" href="/implementation/gap-analysis">Gap Analysis</a><a class="nav-link" href="/implementation/roadmap">Roadmap</a><a class="nav-link" href="/implementation/activity-log">Activity Log</a><a class="nav-link" href="/implementation/site-improvements">Site Improvements</a><a class="nav-link" href="/implementation/clawvault-analysis">ClawVault Analysis</a></div></nav><div class="sidebar-footer"><button class="nav-link logout-link">⎋ Logout</button></div></aside><main class="main-content"><div class="content-wrapper"><div><div class="breadcrumbs">
          <a href="/">Home</a>
          <span class="separator">/</span>
          Architecture
        </div>

        <h1>OpenClaw Architecture</h1>

        <p>OpenClaw is the runtime engine that powers Agent Team OS. It is the daemon process that receives your messages, reasons about them, executes actions, and sends replies back — all while managing concurrency, security, and state isolation across every conversation you have with every agent, on every platform.</p>

        <p>Understanding how OpenClaw works helps you reason about why things happen the way they do — why an agent pauses before replying, why two conversations never interfere with each other, and why the system feels like a single coherent assistant even though it spans Discord, WhatsApp, Telegram, and more.</p>

        <h2>The Five Components</h2>

        <p>OpenClaw's architecture is a pipeline. A message enters from one end, flows through a series of components, and produces a reply at the other end. Each component has a single, well-defined responsibility:</p>

        <div class="arch-pipeline">
          <div class="arch-stage">
            <div class="arch-stage-number">1</div>
            <div class="arch-stage-content">
              <h3><a href="/architecture/channel-adapters">Channel Adapters</a></h3>
              <p>Standardize messages from chat platforms (WhatsApp, Telegram, Discord, Slack, Signal, iMessage, IRC, Google Chat) into a unified internal format. Every platform speaks its own protocol; Channel Adapters translate them into a common language so the rest of the system doesn't need to care where a message came from.</p>
            </div>
          </div>

          <div class="arch-connector">↓</div>

          <div class="arch-stage">
            <div class="arch-stage-number">2</div>
            <div class="arch-stage-content">
              <h3><a href="/architecture/gateway">Gateway</a></h3>
              <p>The central server that routes each incoming message to the correct session, manages authentication, coordinates channel monitors, and provides the WebSocket and HTTP interfaces that everything connects through. The Gateway is the nerve center — it knows about every active session, every connected channel, and every running agent.</p>
            </div>
          </div>

          <div class="arch-connector">↓</div>

          <div class="arch-stage">
            <div class="arch-stage-number">3</div>
            <div class="arch-stage-content">
              <h3><a href="/architecture/lane-queue">Lane Queue</a></h3>
              <p>Executes tasks serially within each session lane to prevent race conditions and state drift. When two messages arrive for the same session simultaneously, the Lane Queue ensures they are processed one at a time, in order. Different sessions run in parallel; within a session, everything is sequential.</p>
            </div>
          </div>

          <div class="arch-connector">↓</div>

          <div class="arch-stage">
            <div class="arch-stage-number">4</div>
            <div class="arch-stage-content">
              <h3><a href="/architecture/agent-runner">Agent Runner</a></h3>
              <p>Orchestrates the reasoning loop — assembles the system prompt and chat history, calls the LLM, handles tool use, and feeds results back until the agent has produced a complete response. This is where the AI "thinks" — the iterative cycle of reasoning, acting, and observing that makes agents capable of complex multi-step tasks.</p>
            </div>
          </div>

          <div class="arch-connector">↓</div>

          <div class="arch-stage">
            <div class="arch-stage-number">5</div>
            <div class="arch-stage-content">
              <h3><a href="/architecture/execution-layer">Execution Layer</a></h3>
              <p>Runs shell commands, file operations, and browser automation in a controlled environment and returns structured outputs. When the agent decides to read a file, execute a script, or navigate a web page, the Execution Layer carries out that action safely and reports back what happened.</p>
            </div>
          </div>
        </div>

        <h2>How a Message Flows Through the System</h2>

        <p>Here is what happens when you send a message to an agent — say, you type "What's on my calendar today?" in Discord:</p>

        <ol class="steps">
          <li><strong>Channel Adapter receives the message.</strong> The Discord monitor detects your message via the Discord Bot API. It extracts the text, identifies you as the sender, resolves the conversation thread, and packages everything into a standardized inbound message format. Platform-specific details like Discord's message IDs, guild context, and attachment formats are normalized.</li>
          <li><strong>Gateway routes it to a session.</strong> The Gateway receives the normalized message and determines which agent session it belongs to, based on the channel, your identity, and the conversation context. It resolves the session key (e.g., <code>agent:ember:discord:channel:12345</code>) and prepares the message for processing.</li>
          <li><strong>Lane Queue serializes execution.</strong> The message is enqueued in the session's dedicated lane. If another message for this session is already being processed, yours waits. If you have a separate conversation on WhatsApp, that runs independently in its own lane. The queue ensures your Discord conversation's state is never corrupted by concurrent access.</li>
          <li><strong>Agent Runner orchestrates the response.</strong> Once the lane dequeues your message, the Agent Runner builds the full context: system prompt, workspace files, conversation history, and available tools. It calls the LLM, which might decide to use a tool (like checking a calendar). If so, the Runner executes the tool, feeds the result back to the LLM, and repeats until the model produces a final text response.</li>
          <li><strong>Execution Layer handles tool calls.</strong> When the LLM requests a tool action — say, running a shell command to check your calendar API — the Execution Layer executes it in a controlled environment. The command runs with appropriate permissions, the output is captured and truncated if necessary, and the structured result is returned to the Agent Runner for the next reasoning step.</li>
          <li><strong>Reply flows back out.</strong> The final response text travels back through the Gateway and Channel Adapter, which formats it appropriately for Discord (applying markdown, respecting character limits, handling threading) and sends it as a reply in your Discord channel.</li>
        </ol>

        <div class="callout tip">
          <div class="callout-title">Why This Matters</div>
          <p>This architecture means you can message the same agent from Discord and WhatsApp simultaneously without conflicts. Each conversation gets its own isolated session lane. The agent sees the correct history for each conversation, tools execute without stepping on each other, and replies go back to the right place. The system is designed to be invisible — it just works.</p>
        </div>

        <h2>Key Design Principles</h2>

        <ul>
          <li><strong>Platform agnosticism.</strong> The core logic knows nothing about Discord, WhatsApp, or any specific platform. Channel Adapters abstract that away entirely. Adding a new platform means writing a new adapter — the rest of the system stays unchanged.</li>
          <li><strong>Session isolation.</strong> Every conversation gets its own lane. State never leaks between sessions. Two users talking to the same agent cannot interfere with each other.</li>
          <li><strong>Serial within, parallel across.</strong> Messages within a session are processed sequentially (preventing state corruption). Messages across different sessions are processed in parallel (keeping things responsive).</li>
          <li><strong>Graceful degradation.</strong> If an LLM call fails, the system retries with fallback models. If a tool times out, it returns a structured error. If a channel disconnects, messages queue until it reconnects.</li>
          <li><strong>Everything is a tool.</strong> File reads, shell commands, web searches, browser automation, and even inter-agent communication are all exposed as tools the LLM can call. The Agent Runner doesn't need special logic for each capability — it just orchestrates tool calls.</li>
        </ul>

        <div class="action-section">
          <h2>Explore Each Component</h2>
          <ul>
            <li><a href="/architecture/channel-adapters">Channel Adapters</a> — how chat platforms are unified</li>
            <li><a href="/architecture/gateway">Gateway</a> — the central routing and coordination server</li>
            <li><a href="/architecture/lane-queue">Lane Queue</a> — concurrency isolation and serial execution</li>
            <li><a href="/architecture/agent-runner">Agent Runner</a> — the LLM reasoning loop</li>
            <li><a href="/architecture/execution-layer">Execution Layer</a> — tool execution in a controlled environment</li>
          </ul>
        </div></div><!--$--><!--/$--></div></main></div><script src="/_next/static/chunks/webpack-d282787ed3063711.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[9766,[],\"\"]\n3:I[8924,[],\"\"]\n4:I[3370,[\"7340\",\"static/chunks/app/(authenticated)/layout-8a56e70ab4050a46.js\"],\"default\"]\n8:I[7150,[],\"\"]\n:HL[\"/_next/static/css/56998b7e09014914.css\",\"style\"]\n5:T2443,"])</script><script>self.__next_f.push([1,"\u003cdiv class=\"breadcrumbs\"\u003e\n          \u003ca href=\"/\"\u003eHome\u003c/a\u003e\n          \u003cspan class=\"separator\"\u003e/\u003c/span\u003e\n          Architecture\n        \u003c/div\u003e\n\n        \u003ch1\u003eOpenClaw Architecture\u003c/h1\u003e\n\n        \u003cp\u003eOpenClaw is the runtime engine that powers Agent Team OS. It is the daemon process that receives your messages, reasons about them, executes actions, and sends replies back — all while managing concurrency, security, and state isolation across every conversation you have with every agent, on every platform.\u003c/p\u003e\n\n        \u003cp\u003eUnderstanding how OpenClaw works helps you reason about why things happen the way they do — why an agent pauses before replying, why two conversations never interfere with each other, and why the system feels like a single coherent assistant even though it spans Discord, WhatsApp, Telegram, and more.\u003c/p\u003e\n\n        \u003ch2\u003eThe Five Components\u003c/h2\u003e\n\n        \u003cp\u003eOpenClaw's architecture is a pipeline. A message enters from one end, flows through a series of components, and produces a reply at the other end. Each component has a single, well-defined responsibility:\u003c/p\u003e\n\n        \u003cdiv class=\"arch-pipeline\"\u003e\n          \u003cdiv class=\"arch-stage\"\u003e\n            \u003cdiv class=\"arch-stage-number\"\u003e1\u003c/div\u003e\n            \u003cdiv class=\"arch-stage-content\"\u003e\n              \u003ch3\u003e\u003ca href=\"/architecture/channel-adapters\"\u003eChannel Adapters\u003c/a\u003e\u003c/h3\u003e\n              \u003cp\u003eStandardize messages from chat platforms (WhatsApp, Telegram, Discord, Slack, Signal, iMessage, IRC, Google Chat) into a unified internal format. Every platform speaks its own protocol; Channel Adapters translate them into a common language so the rest of the system doesn't need to care where a message came from.\u003c/p\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n\n          \u003cdiv class=\"arch-connector\"\u003e↓\u003c/div\u003e\n\n          \u003cdiv class=\"arch-stage\"\u003e\n            \u003cdiv class=\"arch-stage-number\"\u003e2\u003c/div\u003e\n            \u003cdiv class=\"arch-stage-content\"\u003e\n              \u003ch3\u003e\u003ca href=\"/architecture/gateway\"\u003eGateway\u003c/a\u003e\u003c/h3\u003e\n              \u003cp\u003eThe central server that routes each incoming message to the correct session, manages authentication, coordinates channel monitors, and provides the WebSocket and HTTP interfaces that everything connects through. The Gateway is the nerve center — it knows about every active session, every connected channel, and every running agent.\u003c/p\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n\n          \u003cdiv class=\"arch-connector\"\u003e↓\u003c/div\u003e\n\n          \u003cdiv class=\"arch-stage\"\u003e\n            \u003cdiv class=\"arch-stage-number\"\u003e3\u003c/div\u003e\n            \u003cdiv class=\"arch-stage-content\"\u003e\n              \u003ch3\u003e\u003ca href=\"/architecture/lane-queue\"\u003eLane Queue\u003c/a\u003e\u003c/h3\u003e\n              \u003cp\u003eExecutes tasks serially within each session lane to prevent race conditions and state drift. When two messages arrive for the same session simultaneously, the Lane Queue ensures they are processed one at a time, in order. Different sessions run in parallel; within a session, everything is sequential.\u003c/p\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n\n          \u003cdiv class=\"arch-connector\"\u003e↓\u003c/div\u003e\n\n          \u003cdiv class=\"arch-stage\"\u003e\n            \u003cdiv class=\"arch-stage-number\"\u003e4\u003c/div\u003e\n            \u003cdiv class=\"arch-stage-content\"\u003e\n              \u003ch3\u003e\u003ca href=\"/architecture/agent-runner\"\u003eAgent Runner\u003c/a\u003e\u003c/h3\u003e\n              \u003cp\u003eOrchestrates the reasoning loop — assembles the system prompt and chat history, calls the LLM, handles tool use, and feeds results back until the agent has produced a complete response. This is where the AI \"thinks\" — the iterative cycle of reasoning, acting, and observing that makes agents capable of complex multi-step tasks.\u003c/p\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n\n          \u003cdiv class=\"arch-connector\"\u003e↓\u003c/div\u003e\n\n          \u003cdiv class=\"arch-stage\"\u003e\n            \u003cdiv class=\"arch-stage-number\"\u003e5\u003c/div\u003e\n            \u003cdiv class=\"arch-stage-content\"\u003e\n              \u003ch3\u003e\u003ca href=\"/architecture/execution-layer\"\u003eExecution Layer\u003c/a\u003e\u003c/h3\u003e\n              \u003cp\u003eRuns shell commands, file operations, and browser automation in a controlled environment and returns structured outputs. When the agent decides to read a file, execute a script, or navigate a web page, the Execution Layer carries out that action safely and reports back what happened.\u003c/p\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n\n        \u003ch2\u003eHow a Message Flows Through the System\u003c/h2\u003e\n\n        \u003cp\u003eHere is what happens when you send a message to an agent — say, you type \"What's on my calendar today?\" in Discord:\u003c/p\u003e\n\n        \u003col class=\"steps\"\u003e\n          \u003cli\u003e\u003cstrong\u003eChannel Adapter receives the message.\u003c/strong\u003e The Discord monitor detects your message via the Discord Bot API. It extracts the text, identifies you as the sender, resolves the conversation thread, and packages everything into a standardized inbound message format. Platform-specific details like Discord's message IDs, guild context, and attachment formats are normalized.\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eGateway routes it to a session.\u003c/strong\u003e The Gateway receives the normalized message and determines which agent session it belongs to, based on the channel, your identity, and the conversation context. It resolves the session key (e.g., \u003ccode\u003eagent:ember:discord:channel:12345\u003c/code\u003e) and prepares the message for processing.\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eLane Queue serializes execution.\u003c/strong\u003e The message is enqueued in the session's dedicated lane. If another message for this session is already being processed, yours waits. If you have a separate conversation on WhatsApp, that runs independently in its own lane. The queue ensures your Discord conversation's state is never corrupted by concurrent access.\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eAgent Runner orchestrates the response.\u003c/strong\u003e Once the lane dequeues your message, the Agent Runner builds the full context: system prompt, workspace files, conversation history, and available tools. It calls the LLM, which might decide to use a tool (like checking a calendar). If so, the Runner executes the tool, feeds the result back to the LLM, and repeats until the model produces a final text response.\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eExecution Layer handles tool calls.\u003c/strong\u003e When the LLM requests a tool action — say, running a shell command to check your calendar API — the Execution Layer executes it in a controlled environment. The command runs with appropriate permissions, the output is captured and truncated if necessary, and the structured result is returned to the Agent Runner for the next reasoning step.\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eReply flows back out.\u003c/strong\u003e The final response text travels back through the Gateway and Channel Adapter, which formats it appropriately for Discord (applying markdown, respecting character limits, handling threading) and sends it as a reply in your Discord channel.\u003c/li\u003e\n        \u003c/ol\u003e\n\n        \u003cdiv class=\"callout tip\"\u003e\n          \u003cdiv class=\"callout-title\"\u003eWhy This Matters\u003c/div\u003e\n          \u003cp\u003eThis architecture means you can message the same agent from Discord and WhatsApp simultaneously without conflicts. Each conversation gets its own isolated session lane. The agent sees the correct history for each conversation, tools execute without stepping on each other, and replies go back to the right place. The system is designed to be invisible — it just works.\u003c/p\u003e\n        \u003c/div\u003e\n\n        \u003ch2\u003eKey Design Principles\u003c/h2\u003e\n\n        \u003cul\u003e\n          \u003cli\u003e\u003cstrong\u003ePlatform agnosticism.\u003c/strong\u003e The core logic knows nothing about Discord, WhatsApp, or any specific platform. Channel Adapters abstract that away entirely. Adding a new platform means writing a new adapter — the rest of the system stays unchanged.\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eSession isolation.\u003c/strong\u003e Every conversation gets its own lane. State never leaks between sessions. Two users talking to the same agent cannot interfere with each other.\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eSerial within, parallel across.\u003c/strong\u003e Messages within a session are processed sequentially (preventing state corruption). Messages across different sessions are processed in parallel (keeping things responsive).\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eGraceful degradation.\u003c/strong\u003e If an LLM call fails, the system retries with fallback models. If a tool times out, it returns a structured error. If a channel disconnects, messages queue until it reconnects.\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eEverything is a tool.\u003c/strong\u003e File reads, shell commands, web searches, browser automation, and even inter-agent communication are all exposed as tools the LLM can call. The Agent Runner doesn't need special logic for each capability — it just orchestrates tool calls.\u003c/li\u003e\n        \u003c/ul\u003e\n\n        \u003cdiv class=\"action-section\"\u003e\n          \u003ch2\u003eExplore Each Component\u003c/h2\u003e\n          \u003cul\u003e\n            \u003cli\u003e\u003ca href=\"/architecture/channel-adapters\"\u003eChannel Adapters\u003c/a\u003e — how chat platforms are unified\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"/architecture/gateway\"\u003eGateway\u003c/a\u003e — the central routing and coordination server\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"/architecture/lane-queue\"\u003eLane Queue\u003c/a\u003e — concurrency isolation and serial execution\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"/architecture/agent-runner\"\u003eAgent Runner\u003c/a\u003e — the LLM reasoning loop\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"/architecture/execution-layer\"\u003eExecution Layer\u003c/a\u003e — tool execution in a controlled environment\u003c/li\u003e\n          \u003c/ul\u003e\n        \u003c/div\u003e"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"vzbdtBP5U_venz5tN8oS4\",\"p\":\"\",\"c\":[\"\",\"architecture\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"(authenticated)\",{\"children\":[\"architecture\",{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/56998b7e09014914.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[\"(authenticated)\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"body\",null,{\"children\":[[\"$\",\"input\",null,{\"type\":\"checkbox\",\"id\":\"menu-toggle\",\"className\":\"menu-toggle\"}],[\"$\",\"label\",null,{\"htmlFor\":\"menu-toggle\",\"className\":\"hamburger\",\"aria-label\":\"Toggle navigation\",\"children\":\"☰\"}],[\"$\",\"label\",null,{\"htmlFor\":\"menu-toggle\",\"className\":\"overlay\"}],[\"$\",\"div\",null,{\"className\":\"site-wrapper\",\"children\":[[\"$\",\"$L4\",null,{}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"div\",null,{\"className\":\"content-wrapper\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:notFound:0:1:props:style\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:notFound:0:1:props:children:props:children:1:props:style\",\"children\":404}],[\"$\",\"div\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:notFound:0:1:props:children:props:children:2:props:style\",\"children\":[\"$\",\"h2\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:notFound:0:1:props:children:props:children:2:props:children:props:style\",\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}]]}]]}],{\"children\":[\"architecture\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$5\"}}],null,\"$L6\"]}],{},null,false]},null,false]},null,false]},null,false],\"$L7\",false]],\"m\":\"$undefined\",\"G\":[\"$8\",[]],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"9:I[4431,[],\"OutletBoundary\"]\nb:I[5278,[],\"AsyncMetadataOutlet\"]\nd:I[4431,[],\"ViewportBoundary\"]\nf:I[4431,[],\"MetadataBoundary\"]\n10:\"$Sreact.suspense\"\n6:[\"$\",\"$L9\",null,{\"children\":[\"$La\",[\"$\",\"$Lb\",null,{\"promise\":\"$@c\"}]]}]\n7:[\"$\",\"$1\",\"h\",{\"children\":[null,[[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}],null],[\"$\",\"$Lf\",null,{\"children\":[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$10\",null,{\"fallback\":null,\"children\":\"$L11\"}]}]}]]}]\n"])</script><script>self.__next_f.push([1,"e:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\na:null\n"])</script><script>self.__next_f.push([1,"c:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"OpenClaw Architecture — Agent Team OS Guide\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Your personal AI agent team, working together to keep your life organized.\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"11:\"$c:metadata\"\n"])</script></body></html>