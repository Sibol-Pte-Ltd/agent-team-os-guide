<!DOCTYPE html><!--vzbdtBP5U_venz5tN8oS4--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/56998b7e09014914.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-d282787ed3063711.js"/><script src="/_next/static/chunks/4bd1b696-f785427dddbba9fb.js" async=""></script><script src="/_next/static/chunks/1255-29325acccda77703.js" async=""></script><script src="/_next/static/chunks/main-app-035730848130ded3.js" async=""></script><script src="/_next/static/chunks/app/(authenticated)/layout-8a56e70ab4050a46.js" async=""></script><title>Lane Queue — OpenClaw Architecture</title><meta name="description" content="Your personal AI agent team, working together to keep your life organized."/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div hidden=""><!--$--><!--/$--></div><input type="checkbox" id="menu-toggle" class="menu-toggle"/><label for="menu-toggle" class="hamburger" aria-label="Toggle navigation">☰</label><label for="menu-toggle" class="overlay"></label><div class="site-wrapper"><aside class="sidebar"><div class="sidebar-header"><h1>Agent Team OS</h1><div class="subtitle">User Guide</div></div><nav><div class="nav-section"><a class="nav-link" href="/">Home</a></div><div class="nav-section"><div class="nav-section-title">Getting Started</div><a class="nav-link" href="/getting-started">Quick Start</a><a class="nav-link" href="/getting-started/first-day">Your First Day</a><a class="nav-link" href="/getting-started/setup-checklist">Setup Checklist</a></div><div class="nav-section"><div class="nav-section-title">Notes &amp; Sync</div><a class="nav-link" href="/life-os">What is Notes</a><a class="nav-link" href="/life-os/daily-workflow">Daily Workflow</a><a class="nav-link" href="/life-os/templates">Templates</a><a class="nav-link" href="/life-os/logseq-tips">LogSeq Tips</a></div><div class="nav-section"><div class="nav-section-title">Agents</div><a class="nav-link" href="/agents">Meet Your Agents</a><a class="nav-link" href="/agents/ember">Ember</a><a class="nav-link" href="/agents/scout">Scout</a><a class="nav-link" href="/agents/forge">Forge</a><a class="nav-link" href="/agents/architect">Architect</a><a class="nav-link" href="/agents/trust-levels">Trust Levels</a></div><div class="nav-section"><div class="nav-section-title">Cadence</div><a class="nav-link" href="/cadence">Overview</a><a class="nav-link" href="/cadence/morning-report">Morning Report</a><a class="nav-link" href="/cadence/evening-checkin">Evening Check-in</a><a class="nav-link" href="/cadence/weekly-review">Weekly Review</a><a class="nav-link" href="/cadence/monthly-review">Monthly Review</a></div><div class="nav-section"><div class="nav-section-title">OpenClaw Architecture</div><a class="nav-link" href="/architecture">Overview</a><a class="nav-link" href="/architecture/channel-adapters">Channel Adapters</a><a class="nav-link" href="/architecture/gateway">Gateway</a><a class="nav-link active" href="/architecture/lane-queue">Lane Queue</a><a class="nav-link" href="/architecture/agent-runner">Agent Runner</a><a class="nav-link" href="/architecture/execution-layer">Execution Layer</a></div><div class="nav-section"><div class="nav-section-title">Automation</div><a class="nav-link" href="/automation">Overview</a><a class="nav-link" href="/automation/cron-jobs">Cron Jobs</a><a class="nav-link" href="/automation/notifications">Notifications</a></div><div class="nav-section"><div class="nav-section-title">Troubleshooting</div><a class="nav-link" href="/troubleshooting">Common Issues</a><a class="nav-link" href="/troubleshooting/syncthing">Syncthing</a><a class="nav-link" href="/troubleshooting/faq">FAQ</a></div><div class="nav-section"><div class="nav-section-title">Reference</div><a class="nav-link" href="/reference/commands">Commands</a><a class="nav-link" href="/reference/file-locations">File Locations</a><a class="nav-link" href="/reference/glossary">Glossary</a><a class="nav-link" href="/reference/changelog">Changelog</a></div><div class="nav-section"><div class="nav-section-title">Implementation</div><a class="nav-link" href="/implementation">Status</a><a class="nav-link" href="/implementation/gap-analysis">Gap Analysis</a><a class="nav-link" href="/implementation/roadmap">Roadmap</a><a class="nav-link" href="/implementation/activity-log">Activity Log</a><a class="nav-link" href="/implementation/site-improvements">Site Improvements</a><a class="nav-link" href="/implementation/clawvault-analysis">ClawVault Analysis</a></div></nav><div class="sidebar-footer"><button class="nav-link logout-link">⎋ Logout</button></div></aside><main class="main-content"><div class="content-wrapper"><div><div class="breadcrumbs">
          <a href="/">Home</a>
          <span class="separator">/</span>
          <a href="/architecture">Architecture</a>
          <span class="separator">/</span>
          Lane Queue
        </div>

        <h1>Lane Queue</h1>

        <p>The Lane Queue is OpenClaw's concurrency management system. It answers a deceptively simple question: when two messages arrive at the same time, what happens? The answer is central to the system's reliability — without proper serialization, conversations would corrupt each other's state, tool executions would interleave unpredictably, and the entire system would become unreliable.</p>

        <p>The Lane Queue solves this with a straightforward principle: <strong>serial within a session, parallel across sessions.</strong></p>

        <h2>The Problem It Solves</h2>

        <p>Consider what happens when you send two messages in quick succession to the same agent on Discord:</p>

        <ol>
          <li>Message 1: "Check my email for anything urgent"</li>
          <li>Message 2: "Also, what's the weather in Berlin?"</li>
        </ol>

        <p>Without serialization, both messages would be processed simultaneously. Both would read the same conversation history. Both would append to the session transcript at the same time. The agent might try to execute shell commands from both runs concurrently, producing interleaved output. The conversation history would become corrupted — replies might reference the wrong context, tool results might be attributed to the wrong request.</p>

        <p>The Lane Queue prevents this by ensuring Message 2 waits until Message 1 has fully completed — including all LLM calls, tool executions, and transcript updates — before processing begins.</p>

        <h2>How Lanes Work</h2>

        <p>A <strong>lane</strong> is a named serial queue. Each lane processes tasks one at a time (or up to a configurable concurrency limit). Different lanes operate independently and in parallel.</p>

        <p>OpenClaw uses four types of lanes:</p>

        <table class="ref-table">
          <thead>
            <tr>
              <th>Lane</th>
              <th>Purpose</th>
              <th>Default Concurrency</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><strong>Main</strong></td><td>Primary message processing for user conversations</td><td>Configurable (typically 1–4)</td></tr>
            <tr><td><strong>Cron</strong></td><td>Scheduled task execution (heartbeats, reports)</td><td>1</td></tr>
            <tr><td><strong>Subagent</strong></td><td>Subagent spawning and execution</td><td>Configurable</td></tr>
            <tr><td><strong>Nested</strong></td><td>Nested agent invocations within a run</td><td>1</td></tr>
          </tbody>
        </table>

        <p>Within each lane type, individual sessions get their own sub-lane. When a message arrives for session <code>agent:ember:discord:dm:12345</code>, it is enqueued in that session's specific lane: <code>session:agent:ember:discord:dm:12345</code>. A different session's messages go to a different lane and run in parallel.</p>

        <h2>Queuing and Draining</h2>

        <p>When a task is enqueued in a lane, here is what happens:</p>

        <ol class="steps">
          <li><strong>Enqueue.</strong> The task (a function that returns a Promise) is added to the lane's queue along with timing metadata. The queue depth and wait position are logged for diagnostics.</li>
          <li><strong>Check capacity.</strong> If the number of active tasks in the lane is below the concurrency limit, the task starts immediately. Otherwise, it waits.</li>
          <li><strong>Execute.</strong> When the task reaches the front of the queue and capacity is available, it begins execution. The lane tracks it as an active task.</li>
          <li><strong>Complete.</strong> When the task finishes (success or error), it is removed from the active set and the queue drains the next waiting task, if any.</li>
          <li><strong>Warning.</strong> If a task waits longer than a configurable threshold before starting, a diagnostic warning is emitted. This helps identify bottlenecks — for example, a particularly slow agent run blocking subsequent messages.</li>
        </ol>

        <h2>Session-Level Isolation</h2>

        <p>The key insight is that <em>session lanes are named after their session key</em>. This means:</p>

        <ul>
          <li>Your Discord DM with Ember (<code>session:agent:ember:discord:dm:you</code>) and your WhatsApp chat with Ember (<code>session:agent:ember:whatsapp:dm:you</code>) are separate lanes — they run in parallel.</li>
          <li>Your conversation and another user's conversation with the same agent are separate lanes — they never interfere.</li>
          <li>A cron job (heartbeat check) runs in the <code>cron</code> lane — it doesn't block your conversations.</li>
          <li>A subagent spawned by Ember runs in the <code>subagent</code> lane — it has its own concurrency budget.</li>
        </ul>

        <h2>Lane Clearing</h2>

        <p>In some situations, a lane needs to be cleared — all pending tasks are rejected. This happens during:</p>

        <ul>
          <li><strong>Session reset</strong> — when a conversation is reset, queued messages for that session are discarded</li>
          <li><strong>Gateway shutdown</strong> — pending tasks are rejected gracefully during shutdown</li>
          <li><strong>Configuration reload</strong> — when concurrency limits change, the lane state is updated</li>
        </ul>

        <p>Cleared tasks receive a <code>CommandLaneClearedError</code>, which callers can catch and handle appropriately (typically by silently dropping the work).</p>

        <h2>How It Works in Code</h2>

        <p>The Lane Queue is implemented in two key files:</p>

        <ul>
          <li><code>src/process/lanes.ts</code> — defines the <code>CommandLane</code> enum with the four lane types: <code>Main</code>, <code>Cron</code>, <code>Subagent</code>, <code>Nested</code></li>
          <li><code>src/process/command-queue.ts</code> — the queue implementation itself: <code>enqueueCommandInLane()</code> for adding tasks, <code>setCommandLaneConcurrency()</code> for configuring limits, and the internal drain loop that processes queued work</li>
        </ul>

        <p>Session-specific lanes are created dynamically via <code>src/agents/pi-embedded-runner/lanes.ts</code>, which provides <code>resolveSessionLane()</code> and <code>resolveEmbeddedSessionLane()</code> to map session keys to lane names.</p>

        <p>The Gateway applies lane concurrency at startup via <code>server-lanes.ts</code>, reading limits from the configuration file and applying them to each lane type.</p>

        <div class="callout tip">
          <div class="callout-title">Why Not Just Use a Database Lock?</div>
          <p>OpenClaw runs as a single Node.js process, so traditional database-level locking would be overkill. The in-process queue is fast (no network round-trips), simple (just a Map of arrays), and sufficient (there's only one process to coordinate). This is a deliberate architectural choice: the single-process design makes concurrency management trivial compared to distributed systems, at the cost of scaling to a single machine — which is exactly the right tradeoff for a personal AI assistant.</p>
        </div>

        <div class="action-section">
          <h2>Next</h2>
          <ul>
            <li><a href="/architecture/agent-runner">Agent Runner</a> — what happens when a message is dequeued and processed</li>
            <li><a href="/architecture/gateway">Gateway</a> — the server that manages lane configuration</li>
            <li><a href="/architecture">Architecture Overview</a> — see how all five components connect</li>
          </ul>
        </div></div><!--$--><!--/$--></div></main></div><script src="/_next/static/chunks/webpack-d282787ed3063711.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[9766,[],\"\"]\n3:I[8924,[],\"\"]\n4:I[3370,[\"7340\",\"static/chunks/app/(authenticated)/layout-8a56e70ab4050a46.js\"],\"default\"]\n8:I[7150,[],\"\"]\n:HL[\"/_next/static/css/56998b7e09014914.css\",\"style\"]\n5:T1f0d,"])</script><script>self.__next_f.push([1,"\u003cdiv class=\"breadcrumbs\"\u003e\n          \u003ca href=\"/\"\u003eHome\u003c/a\u003e\n          \u003cspan class=\"separator\"\u003e/\u003c/span\u003e\n          \u003ca href=\"/architecture\"\u003eArchitecture\u003c/a\u003e\n          \u003cspan class=\"separator\"\u003e/\u003c/span\u003e\n          Lane Queue\n        \u003c/div\u003e\n\n        \u003ch1\u003eLane Queue\u003c/h1\u003e\n\n        \u003cp\u003eThe Lane Queue is OpenClaw's concurrency management system. It answers a deceptively simple question: when two messages arrive at the same time, what happens? The answer is central to the system's reliability — without proper serialization, conversations would corrupt each other's state, tool executions would interleave unpredictably, and the entire system would become unreliable.\u003c/p\u003e\n\n        \u003cp\u003eThe Lane Queue solves this with a straightforward principle: \u003cstrong\u003eserial within a session, parallel across sessions.\u003c/strong\u003e\u003c/p\u003e\n\n        \u003ch2\u003eThe Problem It Solves\u003c/h2\u003e\n\n        \u003cp\u003eConsider what happens when you send two messages in quick succession to the same agent on Discord:\u003c/p\u003e\n\n        \u003col\u003e\n          \u003cli\u003eMessage 1: \"Check my email for anything urgent\"\u003c/li\u003e\n          \u003cli\u003eMessage 2: \"Also, what's the weather in Berlin?\"\u003c/li\u003e\n        \u003c/ol\u003e\n\n        \u003cp\u003eWithout serialization, both messages would be processed simultaneously. Both would read the same conversation history. Both would append to the session transcript at the same time. The agent might try to execute shell commands from both runs concurrently, producing interleaved output. The conversation history would become corrupted — replies might reference the wrong context, tool results might be attributed to the wrong request.\u003c/p\u003e\n\n        \u003cp\u003eThe Lane Queue prevents this by ensuring Message 2 waits until Message 1 has fully completed — including all LLM calls, tool executions, and transcript updates — before processing begins.\u003c/p\u003e\n\n        \u003ch2\u003eHow Lanes Work\u003c/h2\u003e\n\n        \u003cp\u003eA \u003cstrong\u003elane\u003c/strong\u003e is a named serial queue. Each lane processes tasks one at a time (or up to a configurable concurrency limit). Different lanes operate independently and in parallel.\u003c/p\u003e\n\n        \u003cp\u003eOpenClaw uses four types of lanes:\u003c/p\u003e\n\n        \u003ctable class=\"ref-table\"\u003e\n          \u003cthead\u003e\n            \u003ctr\u003e\n              \u003cth\u003eLane\u003c/th\u003e\n              \u003cth\u003ePurpose\u003c/th\u003e\n              \u003cth\u003eDefault Concurrency\u003c/th\u003e\n            \u003c/tr\u003e\n          \u003c/thead\u003e\n          \u003ctbody\u003e\n            \u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eMain\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003ePrimary message processing for user conversations\u003c/td\u003e\u003ctd\u003eConfigurable (typically 1–4)\u003c/td\u003e\u003c/tr\u003e\n            \u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eCron\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eScheduled task execution (heartbeats, reports)\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003c/tr\u003e\n            \u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eSubagent\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eSubagent spawning and execution\u003c/td\u003e\u003ctd\u003eConfigurable\u003c/td\u003e\u003c/tr\u003e\n            \u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eNested\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eNested agent invocations within a run\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003c/tr\u003e\n          \u003c/tbody\u003e\n        \u003c/table\u003e\n\n        \u003cp\u003eWithin each lane type, individual sessions get their own sub-lane. When a message arrives for session \u003ccode\u003eagent:ember:discord:dm:12345\u003c/code\u003e, it is enqueued in that session's specific lane: \u003ccode\u003esession:agent:ember:discord:dm:12345\u003c/code\u003e. A different session's messages go to a different lane and run in parallel.\u003c/p\u003e\n\n        \u003ch2\u003eQueuing and Draining\u003c/h2\u003e\n\n        \u003cp\u003eWhen a task is enqueued in a lane, here is what happens:\u003c/p\u003e\n\n        \u003col class=\"steps\"\u003e\n          \u003cli\u003e\u003cstrong\u003eEnqueue.\u003c/strong\u003e The task (a function that returns a Promise) is added to the lane's queue along with timing metadata. The queue depth and wait position are logged for diagnostics.\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eCheck capacity.\u003c/strong\u003e If the number of active tasks in the lane is below the concurrency limit, the task starts immediately. Otherwise, it waits.\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eExecute.\u003c/strong\u003e When the task reaches the front of the queue and capacity is available, it begins execution. The lane tracks it as an active task.\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eComplete.\u003c/strong\u003e When the task finishes (success or error), it is removed from the active set and the queue drains the next waiting task, if any.\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eWarning.\u003c/strong\u003e If a task waits longer than a configurable threshold before starting, a diagnostic warning is emitted. This helps identify bottlenecks — for example, a particularly slow agent run blocking subsequent messages.\u003c/li\u003e\n        \u003c/ol\u003e\n\n        \u003ch2\u003eSession-Level Isolation\u003c/h2\u003e\n\n        \u003cp\u003eThe key insight is that \u003cem\u003esession lanes are named after their session key\u003c/em\u003e. This means:\u003c/p\u003e\n\n        \u003cul\u003e\n          \u003cli\u003eYour Discord DM with Ember (\u003ccode\u003esession:agent:ember:discord:dm:you\u003c/code\u003e) and your WhatsApp chat with Ember (\u003ccode\u003esession:agent:ember:whatsapp:dm:you\u003c/code\u003e) are separate lanes — they run in parallel.\u003c/li\u003e\n          \u003cli\u003eYour conversation and another user's conversation with the same agent are separate lanes — they never interfere.\u003c/li\u003e\n          \u003cli\u003eA cron job (heartbeat check) runs in the \u003ccode\u003ecron\u003c/code\u003e lane — it doesn't block your conversations.\u003c/li\u003e\n          \u003cli\u003eA subagent spawned by Ember runs in the \u003ccode\u003esubagent\u003c/code\u003e lane — it has its own concurrency budget.\u003c/li\u003e\n        \u003c/ul\u003e\n\n        \u003ch2\u003eLane Clearing\u003c/h2\u003e\n\n        \u003cp\u003eIn some situations, a lane needs to be cleared — all pending tasks are rejected. This happens during:\u003c/p\u003e\n\n        \u003cul\u003e\n          \u003cli\u003e\u003cstrong\u003eSession reset\u003c/strong\u003e — when a conversation is reset, queued messages for that session are discarded\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eGateway shutdown\u003c/strong\u003e — pending tasks are rejected gracefully during shutdown\u003c/li\u003e\n          \u003cli\u003e\u003cstrong\u003eConfiguration reload\u003c/strong\u003e — when concurrency limits change, the lane state is updated\u003c/li\u003e\n        \u003c/ul\u003e\n\n        \u003cp\u003eCleared tasks receive a \u003ccode\u003eCommandLaneClearedError\u003c/code\u003e, which callers can catch and handle appropriately (typically by silently dropping the work).\u003c/p\u003e\n\n        \u003ch2\u003eHow It Works in Code\u003c/h2\u003e\n\n        \u003cp\u003eThe Lane Queue is implemented in two key files:\u003c/p\u003e\n\n        \u003cul\u003e\n          \u003cli\u003e\u003ccode\u003esrc/process/lanes.ts\u003c/code\u003e — defines the \u003ccode\u003eCommandLane\u003c/code\u003e enum with the four lane types: \u003ccode\u003eMain\u003c/code\u003e, \u003ccode\u003eCron\u003c/code\u003e, \u003ccode\u003eSubagent\u003c/code\u003e, \u003ccode\u003eNested\u003c/code\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ccode\u003esrc/process/command-queue.ts\u003c/code\u003e — the queue implementation itself: \u003ccode\u003eenqueueCommandInLane()\u003c/code\u003e for adding tasks, \u003ccode\u003esetCommandLaneConcurrency()\u003c/code\u003e for configuring limits, and the internal drain loop that processes queued work\u003c/li\u003e\n        \u003c/ul\u003e\n\n        \u003cp\u003eSession-specific lanes are created dynamically via \u003ccode\u003esrc/agents/pi-embedded-runner/lanes.ts\u003c/code\u003e, which provides \u003ccode\u003eresolveSessionLane()\u003c/code\u003e and \u003ccode\u003eresolveEmbeddedSessionLane()\u003c/code\u003e to map session keys to lane names.\u003c/p\u003e\n\n        \u003cp\u003eThe Gateway applies lane concurrency at startup via \u003ccode\u003eserver-lanes.ts\u003c/code\u003e, reading limits from the configuration file and applying them to each lane type.\u003c/p\u003e\n\n        \u003cdiv class=\"callout tip\"\u003e\n          \u003cdiv class=\"callout-title\"\u003eWhy Not Just Use a Database Lock?\u003c/div\u003e\n          \u003cp\u003eOpenClaw runs as a single Node.js process, so traditional database-level locking would be overkill. The in-process queue is fast (no network round-trips), simple (just a Map of arrays), and sufficient (there's only one process to coordinate). This is a deliberate architectural choice: the single-process design makes concurrency management trivial compared to distributed systems, at the cost of scaling to a single machine — which is exactly the right tradeoff for a personal AI assistant.\u003c/p\u003e\n        \u003c/div\u003e\n\n        \u003cdiv class=\"action-section\"\u003e\n          \u003ch2\u003eNext\u003c/h2\u003e\n          \u003cul\u003e\n            \u003cli\u003e\u003ca href=\"/architecture/agent-runner\"\u003eAgent Runner\u003c/a\u003e — what happens when a message is dequeued and processed\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"/architecture/gateway\"\u003eGateway\u003c/a\u003e — the server that manages lane configuration\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"/architecture\"\u003eArchitecture Overview\u003c/a\u003e — see how all five components connect\u003c/li\u003e\n          \u003c/ul\u003e\n        \u003c/div\u003e"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"vzbdtBP5U_venz5tN8oS4\",\"p\":\"\",\"c\":[\"\",\"architecture\",\"lane-queue\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"(authenticated)\",{\"children\":[\"architecture\",{\"children\":[\"lane-queue\",{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/56998b7e09014914.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[\"(authenticated)\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"body\",null,{\"children\":[[\"$\",\"input\",null,{\"type\":\"checkbox\",\"id\":\"menu-toggle\",\"className\":\"menu-toggle\"}],[\"$\",\"label\",null,{\"htmlFor\":\"menu-toggle\",\"className\":\"hamburger\",\"aria-label\":\"Toggle navigation\",\"children\":\"☰\"}],[\"$\",\"label\",null,{\"htmlFor\":\"menu-toggle\",\"className\":\"overlay\"}],[\"$\",\"div\",null,{\"className\":\"site-wrapper\",\"children\":[[\"$\",\"$L4\",null,{}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"div\",null,{\"className\":\"content-wrapper\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:notFound:0:1:props:style\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:notFound:0:1:props:children:props:children:1:props:style\",\"children\":404}],[\"$\",\"div\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:notFound:0:1:props:children:props:children:2:props:style\",\"children\":[\"$\",\"h2\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:notFound:0:1:props:children:props:children:2:props:children:props:style\",\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}]]}]]}],{\"children\":[\"architecture\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"lane-queue\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$5\"}}],null,\"$L6\"]}],{},null,false]},null,false]},null,false]},null,false]},null,false],\"$L7\",false]],\"m\":\"$undefined\",\"G\":[\"$8\",[]],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"9:I[4431,[],\"OutletBoundary\"]\nb:I[5278,[],\"AsyncMetadataOutlet\"]\nd:I[4431,[],\"ViewportBoundary\"]\nf:I[4431,[],\"MetadataBoundary\"]\n10:\"$Sreact.suspense\"\n6:[\"$\",\"$L9\",null,{\"children\":[\"$La\",[\"$\",\"$Lb\",null,{\"promise\":\"$@c\"}]]}]\n7:[\"$\",\"$1\",\"h\",{\"children\":[null,[[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}],null],[\"$\",\"$Lf\",null,{\"children\":[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$10\",null,{\"fallback\":null,\"children\":\"$L11\"}]}]}]]}]\n"])</script><script>self.__next_f.push([1,"e:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\na:null\n"])</script><script>self.__next_f.push([1,"c:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Lane Queue — OpenClaw Architecture\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Your personal AI agent team, working together to keep your life organized.\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"11:\"$c:metadata\"\n"])</script></body></html>